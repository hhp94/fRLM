% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/estimation_binary.R
\name{funcReg_bayes_tv_binary}
\alias{funcReg_bayes_tv_binary}
\title{LOGISTIC FUNCTIONAL LIFECOURSE MODEL with time varying outcome}
\usage{
funcReg_bayes_tv_binary(
  y,
  X,
  TimeOfMeasurement,
  L = 5,
  covariates = NULL,
  alpha_par = 1,
  beta_par = 1,
  grid = seq(0, 1, l = ncol(X)),
  ...
)
}
\arguments{
\item{y}{The output vector (should be 0 and 1 values).}

\item{X}{A n times M matrix containing the n functionsd evaluated at points specified in grid.}

\item{TimeOfMeasurement}{A vector of the same length as y, indicated the time points at which the outcomes are measured.}

\item{L}{Number of B-splines basis to approximate omega.}

\item{covariates}{A matrix of covariates.}

\item{alpha_par}{Variance yperparameter of the prior of alpha.}

\item{beta_par}{Hyperparameter of the dirichlet prior of beta.}

\item{grid}{A vector of the points at which the functions are evaluated.}

\item{...}{Optional parameters to pass to the stan function.}
}
\value{
An list containing estimates for alpha, delta, beta, gamma, and sigma2.
}
\description{
Estimate a logistic functional regression where final outcomes are not measured at the same times.
}
\section{y_i ~ Bernouilli(mu_i)}{

}

\section{g(mu_i) = delta int_0^T_i X_i(t) * omega(t) dt + C_i' alpha}{
where T_i is the time point at which the outcome is measured.
}

\examples{
library(fRLM)
library(dplyr)
library(devtools)
library(rstan)
# parallel computing for the bayesian fit:
# library("rstan") # observe startup messages
# options(mc.cores = parallel::detectCores())
# rstan_options(auto_write = TRUE)
n <- 5000
L <- 7
Nrange <- 8:10
Nvec <- sample( Nrange, n, replace = TRUE )

# Parameters:
omega <- function(t) cos(2*pi*t) + 1
alpha <- -2
delta <- 1
grid <- seq(0,1, l = 150 )

# 1) Simulations:
sim <- simulateFRLM_tv_binary( n, alpha = alpha, delta = delta, omega = omega )
tobs <- lapply( 1:n, function(i){
  u <- runif( Nvec[i], min = 0.3, max = 0.7)
  cumsum(u) / sum(u) * sim$lastExpo[i]
})
# tobs <- c( sort( runif( Nvec[i] - 1, max = sim$lastExpo[i] ) ), sim$lastExpo[i] ) 
Xobs <- lapply( 1:n, function(i) round( sim$functionalCovariates[[i]]( tobs[[i]] ), 3 ) )

# 2) Fit gaussian processes:
gpfitList <- lapply( 1:n, function(i) gpFit( tobs[[i]], Xobs[[i]], nugget = 0.001 ) )
pred <- t( sapply( gpfitList, predict, tnew = grid ) )
plot(gpfitList[[ sample(1:n, 1)]])

# 3) fit:
# fit <- funcReg_bayes_binary(sim$y, pred, warmup = 2000, iter = 4000 )
# plot(fit)
# lines(omega(grid) ~ grid)

fit2 <- funcReg_bayes_tv_binary(sim$y, pred, sim$lastExpo, warmup = 2000, iter = 4000 )
plot(fit2)
lines(omega(grid) ~ grid)

}
